import { type Tab, type TabGroup } from "../bridge/types";

type GroupTabsOptions = {
  tabs: Tab[];
  existingGroups?: TabGroup[];
  force?: boolean;
  now?: number;
  singletonThreshold?: number;
};

type GroupTabsResult = {
  groups: TabGroup[];
  tabIdToGroupId: Record<string, string>;
};

const STRONG_DOMAIN_RULES: Array<{ name: string; match: (host: string, rootDomain: string) => boolean }> = [
  {
    name: "YouTube",
    match: (host, root) =>
      host === "youtube.com" || host.endsWith(".youtube.com") || host === "youtu.be" || root === "youtu.be",
  },
  {
    name: "Google Docs",
    match: (host) => host === "docs.google.com",
  },
  {
    name: "Google Drive",
    match: (host) => host === "drive.google.com",
  },
  {
    name: "GitHub",
    match: (host) => host === "github.com" || host.endsWith(".github.com"),
  },
  {
    name: "Figma",
    match: (host) => host === "figma.com" || host.endsWith(".figma.com"),
  },
  {
    name: "Notion",
    match: (host) => host === "notion.so" || host.endsWith(".notion.so"),
  },
  {
    name: "Mail",
    match: (host) => host === "mail.google.com" || host === "outlook.live.com",
  },
  {
    name: "Social",
    match: (host) =>
      host === "x.com" ||
      host === "twitter.com" ||
      host.endsWith(".twitter.com") ||
      host === "instagram.com" ||
      host.endsWith(".instagram.com") ||
      host === "tiktok.com" ||
      host.endsWith(".tiktok.com") ||
      host === "reddit.com" ||
      host.endsWith(".reddit.com"),
  },
  {
    name: "Shopping",
    match: (host, root) =>
      root.startsWith("amazon.") ||
      root.startsWith("ebay.") ||
      host === "etsy.com" ||
      host.endsWith(".etsy.com"),
  },
];

const KEYWORD_RULES: Array<{ name: string; keywords: string[] }> = [
  { name: "Docs", keywords: ["doc", "docs", "sheet", "slides", "notion"] },
  { name: "Dev", keywords: ["issue", "pull request", "pr", "commit", "repo"] },
  { name: "Shopping", keywords: ["invoice", "receipt", "checkout", "order"] },
  { name: "Accounts", keywords: ["login", "sign in", "auth"] },
  { name: "Reference", keywords: ["tutorial", "guide", "docs"] },
];

const STRONG_GROUP_NAMES = new Set(STRONG_DOMAIN_RULES.map((rule) => rule.name));

const MULTI_PART_TLDS = [
  "co.uk",
  "org.uk",
  "gov.uk",
  "ac.uk",
  "com.au",
  "net.au",
  "org.au",
  "co.nz",
  "com.br",
  "com.mx",
  "co.jp",
  "co.kr",
  "com.sg",
  "com.tr",
];

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 48);

const normalizeHost = (host: string) => host.replace(/^www\./, "").toLowerCase();

const getHost = (url: string) => {
  try {
    if (!url) return "";
    const parsed = new URL(url);
    return normalizeHost(parsed.hostname);
  } catch {
    return "";
  }
};

const getRegistrableDomain = (host: string) => {
  if (!host) return "";
  const normalized = normalizeHost(host);
  const parts = normalized.split(".");
  if (parts.length <= 2) return normalized;

  const lastTwo = parts.slice(-2).join(".");
  const lastThree = parts.slice(-3).join(".");
  if (MULTI_PART_TLDS.includes(lastTwo)) {
    return parts.slice(-3).join(".");
  }
  if (MULTI_PART_TLDS.includes(lastThree)) {
    return parts.slice(-4).join(".");
  }
  return lastTwo;
};

const findStrongGroup = (host: string, rootDomain: string) => {
  const normalized = normalizeHost(host);
  const root = normalizeHost(rootDomain);
  for (const rule of STRONG_DOMAIN_RULES) {
    if (rule.match(normalized, root)) {
      return rule.name;
    }
  }
  return null;
};

const findKeywordGroup = (title: string) => {
  const lowered = title.toLowerCase();
  for (const rule of KEYWORD_RULES) {
    if (rule.keywords.some((keyword) => lowered.includes(keyword))) {
      return rule.name;
    }
  }
  return null;
};

const buildGroupId = (name: string) => `auto-${slugify(name) || "group"}`;

export const groupTabs = ({
  tabs,
  existingGroups = [],
  force = false,
  now = 0,
  singletonThreshold = 12,
}: GroupTabsOptions): GroupTabsResult => {
  const tabIndexById = new Map(tabs.map((tab, index) => [tab.id, index]));

  const userGroups = force
    ? []
    : existingGroups
        .filter((group) => !group.isAutoGenerated)
        .map((group) => ({
          ...group,
          tabIds: group.tabIds.filter((tabId) => tabIndexById.has(tabId)),
        }))
        .filter((group) => group.tabIds.length > 0);

  const reservedTabIds = new Set<string>();
  for (const group of userGroups) {
    group.tabIds.forEach((tabId) => reservedTabIds.add(tabId));
  }

  const autoTabs = force ? tabs : tabs.filter((tab) => !reservedTabIds.has(tab.id));

  const autoGroups = new Map<
    string,
    { name: string; tabIds: string[]; orderIndex: number; isStrong: boolean }
  >();
  const tabIdToGroupKey: Record<string, string> = {};

  autoTabs.forEach((tab, index) => {
    const host = getHost(tab.url);
    const rootDomain = getRegistrableDomain(host);
    const strongGroup = host ? findStrongGroup(host, rootDomain) : null;
    const keywordGroup =
      !strongGroup && tab.title ? findKeywordGroup(tab.title) : null;
    const groupName =
      strongGroup ||
      keywordGroup ||
      rootDomain ||
      host ||
      (tab.title ? tab.title.trim() : "") ||
      "Untitled";

    const key = groupName.toLowerCase();
    const existing = autoGroups.get(key);
    if (existing) {
      existing.tabIds.push(tab.id);
      existing.orderIndex = Math.min(existing.orderIndex, index);
    } else {
      autoGroups.set(key, {
        name: groupName,
        tabIds: [tab.id],
        orderIndex: index,
        isStrong: STRONG_GROUP_NAMES.has(groupName),
      });
    }
    tabIdToGroupKey[tab.id] = key;
  });

  const totalTabs = tabs.length;
  if (totalTabs > singletonThreshold) {
    const singletonKeys = Array.from(autoGroups.entries())
      .filter(([, group]) => group.tabIds.length === 1 && !group.isStrong)
      .map(([key]) => key);

    if (singletonKeys.length > 0) {
      const singletonSet = new Set(singletonKeys);
      const miscTabIds: string[] = [];
      autoTabs.forEach((tab) => {
        const groupKey = tabIdToGroupKey[tab.id];
        if (groupKey && singletonSet.has(groupKey)) {
          miscTabIds.push(tab.id);
        }
      });

      singletonKeys.forEach((key) => autoGroups.delete(key));

      const miscKey = "misc";
      const miscGroup = autoGroups.get(miscKey);
      if (miscGroup) {
        miscGroup.tabIds.push(...miscTabIds);
        miscGroup.orderIndex = Math.min(
          miscGroup.orderIndex,
          Math.min(...miscTabIds.map((id) => tabIndexById.get(id) ?? 0))
        );
      } else if (miscTabIds.length > 0) {
        autoGroups.set(miscKey, {
          name: "Misc",
          tabIds: miscTabIds,
          orderIndex: Math.min(...miscTabIds.map((id) => tabIndexById.get(id) ?? 0)),
          isStrong: false,
        });
      }
    }
  }

  const autoGroupList = Array.from(autoGroups.values()).map((group) => ({
    id: buildGroupId(group.name),
    name: group.name,
    tabIds: group.tabIds,
    isAutoGenerated: true,
    createdAt: now,
    orderIndex: group.orderIndex,
  }));

  const userGroupList = userGroups.map((group) => ({
    ...group,
    orderIndex: Math.min(...group.tabIds.map((id) => tabIndexById.get(id) ?? 0)),
  }));

  const mergedGroups = [...userGroupList, ...autoGroupList]
    .sort((a, b) => a.orderIndex - b.orderIndex)
    .map(({ orderIndex, ...group }) => group as TabGroup);

  const tabIdToGroupId: Record<string, string> = {};
  mergedGroups.forEach((group) => {
    group.tabIds.forEach((tabId) => {
      tabIdToGroupId[tabId] = group.id;
    });
  });

  // Safety net: ensure every tab has a group assignment.
  tabs.forEach((tab) => {
    if (!tabIdToGroupId[tab.id]) {
      const fallbackId = buildGroupId("Misc");
      const existingGroup = mergedGroups.find((group) => group.id === fallbackId);
      if (existingGroup) {
        existingGroup.tabIds.push(tab.id);
      } else {
        mergedGroups.push({
          id: fallbackId,
          name: "Misc",
          tabIds: [tab.id],
          isAutoGenerated: true,
          createdAt: now,
        });
      }
      tabIdToGroupId[tab.id] = fallbackId;
    }
  });

  return { groups: mergedGroups, tabIdToGroupId };
};

export type { GroupTabsOptions, GroupTabsResult };
